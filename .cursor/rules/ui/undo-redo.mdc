---
description: Understanding the multi-slice undo/redo system in the UI app
alwaysApply: false
---

# Multi-slice undo/redo system architecture in the UI app

The Drupal Canvas UI app implements an undo/redo system that coordinates across
multiple independent Redux slices.

## Core architecture

The system uses **three coordinated layers**:

1. **`redux-undo`** - Provides individual slice time-travel
   (`past`/`present`/`future`)
2. **`historyEraser`** - Custom enhancer ensuring cross-slice timeline
   consistency
3. **UI slice coordination** - Acts as "traffic controller" for unified
   undo/redo sequence

## Key components

### Store configuration ([store.ts](mdc:web/modules/contrib/canvas/ui/src/app/store.ts))

```typescript
// Two slices are undoable: layoutModel and pageData
layoutModel: historyEraser<LayoutModelSliceState>(
  undoable(layoutModelReducer, {
    undoType: '@@redux-undo/layoutModel_UNDO',
    redoType: '@@redux-undo/layoutModel_REDO',
    filter: (action, currentState, previousHistory) => {
      // Only track meaningful actions, not initial setup
    },
  }),
  'layoutModel',
  { updatePreview: true }, // Force preview updates on undo/redo
),
```

### The `historyEraser` function

**Purpose:** Maintains timeline consistency across multiple slices

**Key logic:**

```typescript
if (
  type === "ui/pushUndo" && // NEW action happened (not undo/redo)
  action.payload !== thisType && // Action was in DIFFERENT slice
  newState.future.length > 0 // This slice has futures to clear
) {
  return { ...newState, future: [] }; // Clear invalid futures
}
```

**Critical rule:** When you make a NEW action in one slice, all future states in
OTHER slices become invalid (timeline branching).

### UI slice coordination ([uiSlice.ts](mdc:web/modules/contrib/canvas/ui/src/features/ui/uiSlice.ts))

The UI slice tracks the **sequence** of actions across slices:

- `undoStack: ['pageData', 'layoutModel', 'pageData']` - Which slice to undo
  next
- `redoStack: ['layoutModel']` - Which slice to redo next

## Understanding the flow

### When user makes changes:

1. User action dispatched →
   [`layoutModel`](mdc:web/modules/contrib/canvas/ui/src/features/layout/layoutModelSlice.ts)
   or
   [`pageData`](mdc:web/modules/contrib/canvas/ui/src/features/pageData/pageDataSlice.ts)
   slice
2. Middleware intercepts → calls `pushUndo(sliceType)`
3. UI slice records sequence → adds to `undoStack`, clears `redoStack`
4. `historyEraser` clears other slices' futures → prevents timeline conflicts

### When user hits undo:

1. UI determines target → `selectUndoType` (last in `undoStack`)
2. Dispatches slice-specific undo → `@@redux-undo/sliceType_UNDO`
3. `redux-undo` restores state → moves present→future, past→present
4. UI updates stacks → moves item from undo to redo stack

## Critical implementation notes

### Timeline consistency rules:

- **New actions clear ALL futures** (same-slice via redux-undo, cross-slice via
  historyEraser)
- **Undo/redo preserves futures** (navigating existing valid states)
- **Only one timeline branch is valid** at any time

### What `historyEraser` does vs. doesn't do:

- ✅ **Does:** Clear futures when OTHER slices make new actions
- ✅ **Does:** Force state properties on historical states (e.g.,
  `updatePreview: true`)
- ❌ **Doesn't:** Merge timelines (they remain separate)
- ❌ **Doesn't:** Trigger on undo/redo operations (only on `ui/pushUndo`)

### Middleware responsibilities ([undoRedoActionIdMiddleware](mdc:web/modules/contrib/canvas/ui/src/app/store.ts)):

```typescript
// Auto-tracks undoable actions
const [slice] = type.split("/");
if (slice === "layoutModel" || slice === "pageData") {
  store.dispatch(pushUndo(slice as UndoRedoType));
}
```

## Testing considerations

- E2E tests verify keyboard shortcuts and UI interactions
- Unit tests verify complex state transitions (489 lines in
  [`undo-redo-timeline.cy.js`](mdc:web/modules/contrib/canvas/ui/tests/unit/undo-redo-timeline.cy.js))
- Key test assertion: `expect(pageData.future).to.have.lengthOf(0)` after
  cross-slice actions

## Adding a new undoable slice

Follow these steps to make a new Redux slice participate in the undo/redo
system:

### 1. Wrap your reducer in store configuration

In `store.ts`, add your slice to the `combineSlices` call:

```typescript
const rootReducer = combineSlices(
  {
    // Existing slices...
    layoutModel: historyEraser<LayoutModelSliceState>(/* ... */),
    pageData: historyEraser<PageDataState>(/* ... */),

    // Your new slice:
    newSlice: historyEraser<NewSliceState>(
      undoable(newSliceReducer, {
        undoType: "@@redux-undo/newSlice_UNDO",
        redoType: "@@redux-undo/newSlice_REDO",
        filter: (action, currentState, previousHistory) => {
          // Only track meaningful actions, not initial setup
          const { present } = previousHistory;
          return (
            Object.keys(present).length > 0 &&
            action.type !== setInitialNewSlice.type
          );
        },
      }),
      "newSlice",
      // Optional: force state properties on undo/redo
      // Example: { updatePreview: true } ensures ALL historical states
      // have updatePreview: true, regardless of original value
    ),
  },
  // Other slices...
);
```

### 2. Update the UndoRedoType

In `uiSlice.ts`, extend the type definition:

```typescript
export type UndoRedoType = "layoutModel" | "pageData" | "newSlice";
```

### 3. Update the middleware

In `store.ts`, modify the `undoRedoActionIdMiddleware` to track your slice:

```typescript
const [slice] = type.split("/");
if (slice === "layoutModel" || slice === "pageData" || slice === "newSlice") {
  store.dispatch(pushUndo(slice as UndoRedoType));
}
```

### 4. Import required dependencies

Ensure you have the necessary imports in `store.ts`:

```typescript
import {
  newSliceReducer,
  setInitialNewSlice,
} from "@/features/newSlice/newSliceSlice";
import type { NewSliceState } from "@/features/newSlice/newSliceSlice";
```

### Key considerations:

- **Filter function:** Define which actions should be undoable (exclude initial
  setup actions)
- **Force state properties:** Use the third parameter to override properties on
  ALL historical states (past/future). Example: `{ updatePreview: true }`
  ensures every undo/redo triggers a preview update, regardless of the original
  state
- **Action naming:** Follow the `@@redux-undo/sliceName_UNDO/REDO` pattern
- **Type safety:** Update `UndoRedoType` to maintain TypeScript safety

## User experience

Users experience **linear undo/redo** across the entire app, but the system
maintains architectural benefits of separate, focused slices. The coordination
creates the illusion of merged timelines while keeping implementation clean.

## Common misconceptions

1. **"Timelines are merged"** → FALSE: They remain separate, coordinated through
   UI slice
2. **"historyEraser clears all futures"** → FALSE: Only clears when OTHER slices
   act
3. **"UI slice stores actual data"** → FALSE: Only stores sequence metadata
